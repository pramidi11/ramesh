/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package logbook;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.JsonSerializable;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.common.base.Strings;
import okhttp3.*;
import org.openqa.selenium.By;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.chrome.ChromeDriver;
import org.openqa.selenium.chrome.ChromeOptions;

import javax.net.ssl.HostnameVerifier;
import javax.net.ssl.SSLSession;
import java.io.IOException;
import java.lang.reflect.Field;
import java.net.URISyntaxException;
import java.sql.Time;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.concurrent.ThreadLocalRandom;

public class Runner {

    private WebDriver webDriver;
    private final ObjectMapper objectMapper = new ObjectMapper();

    public void setup() {
        ChromeOptions chromeOptions = new ChromeOptions();
        chromeOptions.addArguments("--headless");
        chromeOptions.addArguments("--no-sandbox");
        chromeOptions.addArguments("----disable-dev-shm-usage");
        System.setProperty("webdriver.chrome.driver", System.getProperty("user.dir") + "/src/main/resources/chromedriver");
        webDriver = new ChromeDriver(chromeOptions);
        webDriver.get("http://logbook.pieface.com.au/");
        webDriver.findElement(By.xpath("//*[@id=\"navbarCollapse\"]/div[2]/a")).click();
        webDriver.findElement(By.id("Input_ExternalId")).sendKeys("3389");
        webDriver.findElement(By.id("Input_Password")).sendKeys("3389");
        webDriver.findElement(By.xpath("//*[@id=\"account\"]/div[5]/button")).click();
    }

    public List<TaskHistory> getHistory(String historyDate) throws IOException {
        OkHttpClient client = Client.getUnsafeOkHttpClient();
        MediaType mediaType = MediaType.parse("application/json");
        Request request = new Request.Builder()
            .url("https://logbook.pieface.com.au/api/task/record?date="+historyDate)
            .addHeader("Content-Type", "application/json")
            .addHeader("Cookie", webDriver.manage().getCookies().toString())
            .build();
            Response response = client.newCall(request).execute();
        assert response.body() != null;
        String out = response.body().string();
        System.out.println(out);
        return objectMapper.readValue(out, new TypeReference<List<TaskHistory>>() {});
    }

     public boolean submitTask(String payload, boolean submit) throws IOException {
         HostnameVerifier hostnameVerifier =  new HostnameVerifier() {
             @Override
             public boolean verify(String hostname, SSLSession session) {
                 return true;
             }
         };
        OkHttpClient client = new OkHttpClient.Builder().addInterceptor(new LoggingInterceptor()).hostnameVerifier(hostnameVerifier).build();
        MediaType mediaType = MediaType.parse("application/json");
        RequestBody body = RequestBody.create(mediaType, payload);
        Request request = new Request.Builder()
            .url("https://logbook.pieface.com.au/api/task/record?timeZone=Australia/Melbourne")
            .method("POST", body)
            .addHeader("Content-Type", "application/json")
            .addHeader("Cookie", webDriver.manage().getCookies().toString())
            .build();
        if(submit) {
            Response response = client.newCall(request).execute();
            System.out.println(new ObjectMapper().writerWithDefaultPrettyPrinter().writeValueAsString(response));
            return response.isSuccessful();
        }
        return false;
    }

    public boolean submit(String payload, boolean submit, String url) throws IOException {
        HostnameVerifier hostnameVerifier =  new HostnameVerifier() {
            @Override
            public boolean verify(String hostname, SSLSession session) {
                return true;
            }
        };
        OkHttpClient client = new OkHttpClient.Builder().addInterceptor(new LoggingInterceptor()).hostnameVerifier(hostnameVerifier).build();
        MediaType mediaType = MediaType.parse("application/json");
        RequestBody body = RequestBody.create(mediaType, payload);
        Request request = new Request.Builder()
                .url(url)
                .method("POST", body)
                .addHeader("Content-Type", "application/json")
                .addHeader("Cookie", webDriver.manage().getCookies().toString())
                .build();
        if(submit) {
            Response response = client.newCall(request).execute();
            System.out.println(new ObjectMapper().writerWithDefaultPrettyPrinter().writeValueAsString(response));
            return response.isSuccessful();
        }
        return false;
    }

    public void onDemandTaskLogEntries(String file, String historyDate) throws IOException, URISyntaxException, ParseException, NoSuchFieldException, IllegalAccessException {
        try {
            setup();
            System.out.println("running file " + file);
            ReadCsv readCsv = new ReadCsv();
            List<Task> taskList = readCsv.readTasks(file + ".csv");
            List<Worker> workers = readCsv.readWorkers("employees.csv");
            List<TaskHistory> taskHistories = getHistory(historyDate);
            System.out.println(objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(taskHistories));
            taskList.forEach(task -> {
                task.setEnteredDate(historyDate);
            });
            Calendar c = Calendar.getInstance();
            c.setTime(new SimpleDateFormat("yyyy-MM-dd").parse(historyDate));
            util(file, taskList, workers, c, historyDate);
            webDriver.quit();
        } catch (Exception e) {
            webDriver.quit();
            throw e;
        }
    }

    private void util(String file, List<Task> taskList, List<Worker> workers, Calendar now, String customDate) throws NoSuchFieldException, IllegalAccessException, ParseException {
        int day;
        if (customDate == null) {
           day = now.get(Calendar.DAY_OF_WEEK);
        } else {
            Calendar cal = Calendar.getInstance();
            SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd", Locale.ENGLISH);
            cal.setTime(sdf.parse(customDate));
            day = cal.get(Calendar.DAY_OF_WEEK);
        }
        Worker entry = workers.get(day - 1);
        Field f = entry.getClass().getField(file);
        String value = (String) f.get(entry);
        System.out.println("logging for working day" + day + "- for " + value + "with file " + file);
        taskList.forEach(task -> {
            task.setPerformedBy(value);
            if (customDate != null)
                task.setEnteredDate(customDate);
        });
        taskList.forEach(task -> {
            try {
                task.setSuccess(submitTask(new ObjectMapper().writeValueAsString(task), true));
                System.out.format("%1s%9s%6s%6s%6s \n--------------------------------------------------\n", task.getTaskId(), task.getPerformedBy(), task.getEnteredDate(), task.getEnteredTime(), task.isSuccess());
            } catch (IOException e) {
                e.printStackTrace();
            }
        });
    }

    public String getRandom() {

        String[] ranges = new String[]{"70", "75"};
        Random r = new Random();
        double random = (r.nextInt(21)-10) / 10.0;
        int number = r.nextInt(Integer.parseInt(ranges[1]) - Integer.parseInt(ranges[0])) + Integer.parseInt(ranges[0]);
        System.out.println(ranges[0] + " " + ranges[1] + " " + (random+number) );
        return String.valueOf(random + (double) number);
    }

    public void productEntry(boolean today, String customDate) throws Exception {
        try {
            setup();
            String[] hrs = new String[]{"07", "11", "15", "20"};
            int max = 59;
            int min = 10;
            for (String hr : hrs) {
                String customTime = hr.concat(":" + ThreadLocalRandom.current().nextInt(min, max + 1));
                System.out.println(customTime);
                piesEntries(false, "2023-01-21", customTime, 0, getRandom(), 0, "pies");
                piesEntries(false, "2023-01-21", customTime, 1, null, null, "donuts");
                piesEntries(false, "2023-01-21", customTime, 2, null, null, "sandwich");
            }
            webDriver.quit();
        } catch (Exception e) {
            webDriver.quit();
            throw e;
        }

    }

    public void piesEntries(boolean today, String customDate, String customTime, int productType, String temperature, Integer reasonType, String sheet) throws Exception {
        ReadCsv readCsv = new ReadCsv();
        Pies pies = new Pies();
        pies.setProductType(productType);
        pies.setTemperature(temperature);
        pies.setReasonType(reasonType);
        List<Product> productList = readCsv.readProducts(sheet+".csv");
        pies.setProducts(productList);
        pies.setEnteredTime(customTime);
        if(today) {
            LocalDate dateObj = LocalDate.now();
            DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd");
            String date = dateObj.format(formatter);
            pies.setEnteredDate(date);
        }else {
            if (customDate != null) {
                pies.setEnteredDate(customDate);
            }
        }
        ObjectMapper objectMapper = new ObjectMapper();
        System.out.println(objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(pies));
        submit(objectMapper.writeValueAsString(pies), true, "http://logbook.pieface.com.au/api/product/record?timeZone=Australia/Melbourne");
    }

    public void logBookEntries(boolean fullDay, String customDate) throws Exception {
        try {
            ReadCsv readCsv = new ReadCsv();
            List<Worker> workers = readCsv.readWorkers("employees.csv");
            setup();
            if(!fullDay) {
                Calendar now = Calendar.getInstance();
                int hour = now.get(Calendar.HOUR_OF_DAY);
                String file;
                if ((hour > 9) && (hour < 12)) {
                    file = "nineam";
                } else if ((hour > 13) && (hour < 21)) {
                    file = "onepm";
                } else if (hour > 21) {
                    file = "ninepm";
                } else {
                    throw new Exception("Batch is out of time range");
                }
                System.out.println("running file " + file);
                List<Task> taskList = readCsv.readTasks(file + ".csv");
                util(file, taskList, workers, now, null);
            } else {
                if(customDate != null) {
                    List<TaskHistory> taskHistories = getHistory(customDate);
                    taskHistories.forEach(this::checkIfFilled);
                }
                ArrayList<String> list = new ArrayList<>();
                list.add("nineam");
                list.add("onepm");
                list.add("ninepm");
                list.forEach(entryFile -> {
                    System.out.println("running file " + entryFile);
                    try {
                        List<Task> taskList = readCsv.readTasks(entryFile + ".csv");
                        util(entryFile, taskList, workers, null, customDate);
                    } catch (IOException | IllegalAccessException | URISyntaxException | NoSuchFieldException | ParseException e) {
                        e.printStackTrace();
                    }
                });
            }
            webDriver.quit();
        } catch (Exception e) {
            webDriver.quit();
            throw e;
        }
    }

    private void checkIfFilled(TaskHistory taskHistory) {
        Arrays.stream(taskHistory.getClass().getFields()).forEach(field -> {
            try {
                if(field.get(taskHistory) != null && !field.getName().equals("time")) {
                    System.out.println(field.getName());
                    webDriver.quit();
                    throw new Error("Tasks already filled for date");
                }
            } catch (IllegalAccessException e) {
                e.printStackTrace();
            }
        });
    }

}
